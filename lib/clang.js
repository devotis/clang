(function() {
    var soap = require('soap');

    var clang = {};

    clang.init = function (uuid, version, callback) {
        if (!uuid || !uuid.match(/^([0-9]-)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i)) { //Clang (probably) uses a version 4 UUIDs scheme relying only on random numbers.
            return callback(new Error('uuid missing or invalid')); 
        }
        clang.uuid = uuid;     
        clang.callbackMain = callback; //store the original callback for final
        clang.roundTrips=0
        clang.maxAttempts=10;

        var url = 'https://secure.myclang.com/app/api/soap/public/index.php?wsdl'+(version ? '&version='+version : '');
        console.log('Fetching WSDL and preparing SOAP client...');

        soap.createClient(url, clang.initCallback);
    };

    clang.initCallback = function(err, client) {
        console.log('SOAP client created');

        clang.soap = client.describe();
        clang.objects={};

        var resourceMethods=[]; //TODO not used

        function capitalize(string) {
            return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
        }

        //iterate through all methods supplied in the Clang API
        for (var key in clang.soap.clangAPI.clangPort) {
            var methodNameParts = key.split('_');
            var objectName      = methodNameParts[0];
            var methodName      = methodNameParts[1];

            var method = clang.soap.clangAPI.clangPort[key];
            if (!clang.objects[objectName]) {
                clang.objects[objectName] = {};
            }

            clang.objects[objectName][methodName] = function(clangMethodName) {
                //build new function
                return function (args, callback) {
                    console.log('Invoking SOAP method: ' + clangMethodName + '('+JSON.stringify(args)+')');
                    clang.roundTrips=0;
                    clang.maxAttempts=10;

                    if (!args.uuid) {
                        args.uuid = clang.uuid;
                    }

                    var out;
                    client[clangMethodName](args, function(err, result) {
                        //process results of SOAP call
                        console.log('client.lastRequest', client.lastRequest);
                        var out = clientCallback.call(this, err, result, clangMethodName, undefined, undefined);
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, out);
                    });
                    console.log('Awaiting SOAP response...');
                }
            }(key);
        
            //some method do not output records directly, instead they return a reference to a resource set
            //this bit within if captures these methods and adds a property to indicate
            //that the output has to be fetched through a resourceSet
            if (method.output.code == "xsd:integer" &&
                method.output.msg  == "xsd:long" && 
                [
                    'customer_getTotalNumberOfCustomers',
                    'magentoEmail_insert',
                    'magento_executeAbandonedCart'
                ].indexOf(key) === -1) { //the output of these methods is not referring to a resource but have similar output as the ones that do

                method.useResource = true;
                resourceMatch = methodName.match(/get(\w+)Set/);

                if (resourceMatch) {
                    method.resourceMethod = resourceMatch[1].toLowerCase()+'Set_get'+resourceMatch[1]+'s';
                } else if (methodName == 'getMembers') {
                    method.resourceMethod = 'customerSet_getCustomers';
                } else {
                    method.resourceMethod = objectName+'Set_get'+capitalize(objectName)+'s';
                }
                method.resourceMethod = method.resourceMethod.replace(/ys$/, 'ies');

                if (resourceMethods.indexOf(method.resourceMethod) === -1) {
                    resourceMethods.push(method.resourceMethod);
                    //resourceMethods.push(clang.soap.clangAPI.clangPort[method.resourceMethod]) ;
                }
            }

        }

        console.log('SOAP methods analyzed. Avaliable for CRUD:', Object.keys(clang.objects).join(', '));

        clang.callbackMain(null, clang);
    };

    var clientCallback = function(err, result, clangMethodName, resourceId, resourceMethod) {
        console.log('SOAP response arrived');
        
        //Check for actual SOAP Fault generated by callback in soap/lib/client line 152
        if (err) {
            return;
        }
        //Check for No SOAP Fault, but result code not 0
        if (result.code != 0) {
            err = new Error('No SOAP Fault, but result code not 0: ' + JSON.stringify(result.msg));
            return;
        }
        //checks maximum amount of roundtrips (due to nested call)
        if (clang.roundTrips > clang.maxAttempts) {
            err = new Error('Exceeded the maximum number of attempts');
            return;
        }

        var method = clang.soap.clangAPI.clangPort[clangMethodName];

        //Check for result that should be fetched using new SOAP call
        if (method.useResource || //first attempt trying if resource is READY
            clangMethodName === 'resource_getById' && result.msg.status === 'PROCESSING'    //next attempts trying if resource is READY
        ) {

            resourceId     = resourceId     || result.msg ;//    = (typeof result.msg === "object" ? result.msg.id : result.msg );
            resourceMethod = resourceMethod || method.resourceMethod;
            var resourceArgs   = {
                uuid: uuid,
                resourceId: resourceId
            };

            console.log('Invoking SOAP method to see if resourceId is READY: ' + resourceId);
            clang.roundTrips++;
            client['resource_getById'](resourceArgs, function(err, result) {
                /* result looks like: {
                      "code": 0,
                      "msg": {
                        "id": "147082",
                        "type": "CUSTOMER_SET",
                        "status": "READY",
                        "size": "1"
                      }
                    }
                */
                var out = clientCallback(err, result, 'resource', 'getById', resourceId, resourceMethod);
            });
            clang.roundTrips--;
            console.log('Awaiting SOAP response (for resourceId)...');

            return;
        }
        //When resource is READY fetch the data using the resourceMethod
        if (clangMethodName === 'resource_getById' && result.msg.status === 'READY') {
            console.log('Resource is READY ('+result.msg.size+ ' records)');
            if (result.msg.size > 0) {
                var resourceArgs   = {
                    uuid: uuid,
                    resourceId: resourceId,
                    offset: 0,
                    size: 50
                };
                client[resourceMethod](resourceArgs, function(err, result) {
                    clientCallback(err, result, 'dummy', 'dummy')
                });
                console.log('Awaiting SOAP response (for resource records)...');
            } else {
                res.set({
                    'content-type': 'application/json'
                }).send([]);
                console.log('No records found');
            }

            return;
        }

        //we have 0 or more results. Normalize it to just the array to output
        var msgKeys = Object.keys(result.msg);
        if (msgKeys.length === 0) {
            console.log('No records found');
            return [];
        }
        if (msgKeys.length === 1 && result.msg[msgKeys[0]] instanceof Array) {
            console.log('msg array returned');
            return result.msg[msgKeys[0]]
        }
      
    };

    exports.init = clang.init;
})();